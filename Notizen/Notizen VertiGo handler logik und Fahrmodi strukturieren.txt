void handleWiFi(WiFiServer &server) {
    WiFiClient client = server.available();
    if (!client) return;

    waitForClientData(client);

    String req = client.readStringUntil('\r');
    client.flush();

    Serial.println(req);

    // 1. Joystick: Sonderfall → kurze Antwort
    if (req.indexOf("GET /joy?") != -1) {
		
		//if (manual mode) tue das - else return //Abfragemöglichkeit zum Modus?
        handleJoystick(req, client);   // sendet kurze Antwort
        client.stop();
        return;
    }

    // 2️. Zustandsänderungen (motor on/off)
    handleStatusRequest(req);           // nur Logik

    // 3️. Immer Webseite senden
    sendWebpage(client);
    client.stop();
}









enum ControlMode {
  MANUAL,
  WALL_ALIGN
};

ControlMode mode;
cpp


if (mode == WALL_ALIGN) {
  controller schreibt Motorwerte
} else {
  handleJoystick schreibt Motorwerte
}

-> gleiche variablen schreiben -> handleJoystick müsste im wifiHandler über Bedingung aufgerufen werden (if (manual mode) handleJoystick - else return), damit dieser nicht zusätzlich Variablen im auto-modus schreibt
ODER: unterschiedliche Variablen -> handleMotors bekommt je nach Modus die entsprechenden Variablen


MotorCmd activeCmd;

if (mode == WALL_ALIGN) {
    activeCmd = autoCmd;
} else {
    activeCmd = manualCmd;
}

handleMotors(activeCmd);

--->Vorteile

	✅ Zentrale Stelle für handleMotors
	→ Gut, wenn später noch Logik dazukommt:

	limitCmd(&activeCmd);
	logCmd(activeCmd);
	handleMotors(activeCmd);


	✅ Leichter erweiterbar, wenn mehr Modi kommen

	switch (mode) {
		case WALL_ALIGN: activeCmd = autoCmd; break;
		case MANUAL:     activeCmd = manualCmd; break;
		case SAFE:       activeCmd = stopCmd; break;
	}
	handleMotors(activeCmd);


	✅ Besser testbar/debugbar
	Man kann activeCmd inspizieren, loggen oder manipulieren, bevor er ausgeführt wird.

struct MotorCmd {
    int leftPWM;
    int rightPWM;
    int leftDir;
    int rightDir;
};
cpp


MotorCmd manualCmd;
MotorCmd autoCmd;

//mit structs sinnvoll. erstmal direkt setzen mit autoCmd.speedLeft = x; z.b. und später vlt mit updateAutoCmd(&autoCmd) und void updateManualCmd(MotorCmd *cmd) {cmd->speedLeft  = joystickY + joystickX; } gebündelt setzen